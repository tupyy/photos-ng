// Package http provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package http

import (
	"encoding/json"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for SyncJobStatus.
const (
	Completed SyncJobStatus = "completed"
	Failed    SyncJobStatus = "failed"
	Pending   SyncJobStatus = "pending"
	Running   SyncJobStatus = "running"
	Stopped   SyncJobStatus = "stopped"
)

// Defines values for TaskResultItemType.
const (
	File   TaskResultItemType = "file"
	Folder TaskResultItemType = "folder"
)

// Defines values for TaskResultResult0.
const (
	Ok TaskResultResult0 = "ok"
)

// Defines values for ListMediaParamsDirection.
const (
	Backward ListMediaParamsDirection = "backward"
	Forward  ListMediaParamsDirection = "forward"
)

// Defines values for ListMediaParamsType.
const (
	Photo ListMediaParamsType = "photo"
	Video ListMediaParamsType = "video"
)

// Defines values for ListMediaParamsSortBy.
const (
	CapturedAt ListMediaParamsSortBy = "capturedAt"
	Filename   ListMediaParamsSortBy = "filename"
	Type       ListMediaParamsSortBy = "type"
)

// Defines values for ListMediaParamsSortOrder.
const (
	Asc  ListMediaParamsSortOrder = "asc"
	Desc ListMediaParamsSortOrder = "desc"
)

// Album defines model for Album.
type Album struct {
	Children *[]struct {
		Href string `json:"href"`
		Name string `json:"name"`
	} `json:"children,omitempty"`
	Description *string `json:"description,omitempty"`
	Href        string  `json:"href"`

	// Id Unique identifier for the album
	Id string `json:"id"`

	// Media list of media href
	Media *[]string `json:"media,omitempty"`

	// MediaCount Total media including media of all its children
	MediaCount int `json:"mediaCount"`

	// Name name of the album
	Name string `json:"name"`

	// ParentHref href of the parent
	ParentHref *string `json:"parentHref,omitempty"`

	// Path path of the folder on disk
	Path string `json:"path"`

	// Thumbnail href of the thumbnail
	Thumbnail *string `json:"thumbnail,omitempty"`
}

// Bucket defines model for Bucket.
type Bucket struct {
	// Media list of media hrefs in this bucket
	Media *[]string `json:"media,omitempty"`
	Month *int      `json:"month,omitempty"`
	Year  *int      `json:"year,omitempty"`
}

// CreateAlbumRequest defines model for CreateAlbumRequest.
type CreateAlbumRequest struct {
	// Description Info about the album
	Description *string `json:"description,omitempty"`

	// Name Name of the album
	Name string `json:"name"`

	// ParentId Id of the parent
	ParentId *string `json:"parentId,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code *string `json:"code,omitempty"`

	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Message Error message
	Message string `json:"message"`
}

// ExifHeader defines model for ExifHeader.
type ExifHeader struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// ListAlbumsResponse defines model for ListAlbumsResponse.
type ListAlbumsResponse struct {
	Albums []Album `json:"albums"`

	// Limit Number of albums returned
	Limit int `json:"limit"`

	// Offset Number of albums skipped
	Offset int `json:"offset"`

	// Total Total number of albums
	Total int `json:"total"`
}

// ListMediaResponse defines model for ListMediaResponse.
type ListMediaResponse struct {
	// Limit Number of media items returned
	Limit int     `json:"limit"`
	Media []Media `json:"media"`

	// NextCursor Cursor for next page (base64 encoded)
	NextCursor *string `json:"nextCursor"`
}

// ListSyncJobsResponse defines model for ListSyncJobsResponse.
type ListSyncJobsResponse struct {
	Jobs []SyncJob `json:"jobs"`
}

// Media defines model for Media.
type Media struct {
	AlbumHref  string    `json:"albumHref"`
	CapturedAt time.Time `json:"capturedAt"`

	// Content href of the endpoint serving the content of the media
	Content string       `json:"content"`
	Exif    []ExifHeader `json:"exif"`

	// Filename full path of the media file on the disk
	Filename string `json:"filename"`
	Href     string `json:"href"`
	Id       string `json:"id"`

	// Thumbnail href to thumbnail
	Thumbnail string `json:"thumbnail"`
	Type      string `json:"type"`
}

// StartSyncRequest defines model for StartSyncRequest.
type StartSyncRequest struct {
	// Path The file system path to sync
	Path string `json:"path"`
}

// StartSyncResponse defines model for StartSyncResponse.
type StartSyncResponse struct {
	// Id Unique identifier for the sync job
	Id string `json:"id"`
}

// StatsResponse defines model for StatsResponse.
type StatsResponse struct {
	// CountAlbum Total number of albums
	CountAlbum int `json:"countAlbum"`

	// CountMedia Total number of media items
	CountMedia int `json:"countMedia"`

	// Years List of years that contain media
	Years []int `json:"years"`
}

// SyncAlbumResponse defines model for SyncAlbumResponse.
type SyncAlbumResponse struct {
	// Message Sync completion message
	Message string `json:"message"`

	// SyncedItems Number of items synced
	SyncedItems int `json:"synced_items"`
}

// SyncJob defines model for SyncJob.
type SyncJob struct {
	// CompletedTasks List of processed files with their results
	CompletedTasks []TaskResult `json:"completedTasks"`
	CreatedAt      time.Time    `json:"createdAt"`

	// Duration Duration of the sync job in seconds
	Duration *int `json:"duration,omitempty"`

	// Error Error message if the job failed
	Error      *string    `json:"error,omitempty"`
	FinishedAt *time.Time `json:"finishedAt,omitempty"`

	// Id Unique identifier for the sync job
	Id string `json:"id"`

	// Path The folder path being synchronized
	Path string `json:"path"`

	// RemainingTasks Number of files still to be processed
	RemainingTasks int `json:"remainingTasks"`

	// RemainingTime aproximative ramaining running tile in seconds
	RemainingTime *string    `json:"remainingTime,omitempty"`
	StartedAt     *time.Time `json:"startedAt,omitempty"`

	// Status Current status of the sync job
	Status SyncJobStatus `json:"status"`

	// TotalTasks Total number of files to process
	TotalTasks int `json:"totalTasks"`
}

// SyncJobStatus Current status of the sync job
type SyncJobStatus string

// TaskResult defines model for TaskResult.
type TaskResult struct {
	// Duration time of running in milliseconds
	Duration int `json:"duration"`

	// Item Name of the processed file/folder
	Item     string             `json:"item"`
	ItemType TaskResultItemType `json:"itemType"`
	Result   TaskResult_Result  `json:"result"`
}

// TaskResultItemType defines model for TaskResult.ItemType.
type TaskResultItemType string

// TaskResultResult0 File processed successfully
type TaskResultResult0 string

// TaskResultResult1 Error message if processing failed
type TaskResultResult1 = string

// TaskResult_Result defines model for TaskResult.Result.
type TaskResult_Result struct {
	union json.RawMessage
}

// UpdateAlbumRequest Request body for updating an album
type UpdateAlbumRequest struct {
	Description *string `json:"description,omitempty"`

	// Thumbnail id of the media used as thumbnail
	Thumbnail *string `json:"thumbnail,omitempty"`
}

// UpdateMediaRequest defines model for UpdateMediaRequest.
type UpdateMediaRequest struct {
	// CapturedAt Date when the media was captured
	CapturedAt *openapi_types.Date `json:"capturedAt,omitempty"`

	// Exif EXIF data for the media
	Exif *[]ExifHeader `json:"exif,omitempty"`
}

// BadRequest defines model for BadRequest.
type BadRequest = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// ListAlbumsParams defines parameters for ListAlbums.
type ListAlbumsParams struct {
	// Limit Maximum number of albums to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of albums to skip
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// WithParent If true return albums with parents
	WithParent *bool `form:"withParent,omitempty" json:"withParent,omitempty"`
}

// ListMediaParams defines parameters for ListMedia.
type ListMediaParams struct {
	// Limit Maximum number of media items to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Cursor for pagination (base64 encoded)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Direction Pagination direction
	Direction *ListMediaParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// AlbumId Filter media by album ID
	AlbumId *string `form:"album_id,omitempty" json:"album_id,omitempty"`

	// Type Filter media by type
	Type *ListMediaParamsType `form:"type,omitempty" json:"type,omitempty"`

	// StartDate Filter media captured on or after this date
	StartDate *openapi_types.Date `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate Filter media captured on or before this date
	EndDate *openapi_types.Date `form:"endDate,omitempty" json:"endDate,omitempty"`

	// SortBy Sort media by field
	SortBy *ListMediaParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort order
	SortOrder *ListMediaParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// ListMediaParamsDirection defines parameters for ListMedia.
type ListMediaParamsDirection string

// ListMediaParamsType defines parameters for ListMedia.
type ListMediaParamsType string

// ListMediaParamsSortBy defines parameters for ListMedia.
type ListMediaParamsSortBy string

// ListMediaParamsSortOrder defines parameters for ListMedia.
type ListMediaParamsSortOrder string

// UploadMediaMultipartBody defines parameters for UploadMedia.
type UploadMediaMultipartBody struct {
	// AlbumId ID of the album to upload the media to
	AlbumId string `json:"albumId"`

	// File The media file content
	File openapi_types.File `json:"file"`

	// Filename Original name of the file
	Filename string `json:"filename"`
}

// CreateAlbumJSONRequestBody defines body for CreateAlbum for application/json ContentType.
type CreateAlbumJSONRequestBody = CreateAlbumRequest

// UpdateAlbumJSONRequestBody defines body for UpdateAlbum for application/json ContentType.
type UpdateAlbumJSONRequestBody = UpdateAlbumRequest

// UploadMediaMultipartRequestBody defines body for UploadMedia for multipart/form-data ContentType.
type UploadMediaMultipartRequestBody UploadMediaMultipartBody

// UpdateMediaJSONRequestBody defines body for UpdateMedia for application/json ContentType.
type UpdateMediaJSONRequestBody = UpdateMediaRequest

// StartSyncJobJSONRequestBody defines body for StartSyncJob for application/json ContentType.
type StartSyncJobJSONRequestBody = StartSyncRequest

// AsTaskResultResult0 returns the union data inside the TaskResult_Result as a TaskResultResult0
func (t TaskResult_Result) AsTaskResultResult0() (TaskResultResult0, error) {
	var body TaskResultResult0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTaskResultResult0 overwrites any union data inside the TaskResult_Result as the provided TaskResultResult0
func (t *TaskResult_Result) FromTaskResultResult0(v TaskResultResult0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTaskResultResult0 performs a merge with any union data inside the TaskResult_Result, using the provided TaskResultResult0
func (t *TaskResult_Result) MergeTaskResultResult0(v TaskResultResult0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTaskResultResult1 returns the union data inside the TaskResult_Result as a TaskResultResult1
func (t TaskResult_Result) AsTaskResultResult1() (TaskResultResult1, error) {
	var body TaskResultResult1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTaskResultResult1 overwrites any union data inside the TaskResult_Result as the provided TaskResultResult1
func (t *TaskResult_Result) FromTaskResultResult1(v TaskResultResult1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTaskResultResult1 performs a merge with any union data inside the TaskResult_Result, using the provided TaskResultResult1
func (t *TaskResult_Result) MergeTaskResultResult1(v TaskResultResult1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TaskResult_Result) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TaskResult_Result) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
