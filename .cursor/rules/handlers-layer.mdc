---
description: "Handler layer patterns and responsibilities in Photos NG"
globs: "internal/handlers/v1/*.go"
---

# Handler Layer Architecture

## Responsibilities
The handler layer in [internal/handlers/v1/](mdc:internal/handlers/v1/) serves as the **HTTP boundary** and should ONLY:

1. **HTTP Protocol Handling**: Parse requests, validate input, format responses
2. **Authentication/Authorization**: Validate tokens, check permissions
3. **Input Validation**: Basic request structure validation
4. **Response Formatting**: Convert service results to API types
5. **Error Translation**: Convert internal errors to HTTP status codes

## What Handlers MUST NOT Do

❌ **Business Logic**: No complex calculations or business rules  
❌ **Database Access**: Never interact with datastores directly  
❌ **File System Operations**: No direct file I/O operations  
❌ **Data Transformation**: Complex data processing belongs in services  
❌ **Concurrent Operations**: Leave goroutine management to services  

## Handler Structure Pattern

```go
type ServerImpl struct {
    albumSrv   *services.AlbumService    // Service dependency
    mediaSrv   *services.MediaService    // Service dependency  
    statsSrv   *services.StatsService    // Service dependency
    rootFolder string                    // Configuration only
}
```

### Constructor Pattern
```go
func NewServerV1(dt *pg.Datastore, rootFolder string) *ServerImpl {
    return &ServerImpl{
        albumSrv:   services.NewAlbumService(dt, fs.NewFsDatastore(rootFolder)),
        mediaSrv:   services.NewMediaService(dt, fs.NewFsDatastore(rootFolder)),
        statsSrv:   services.NewStatsService(dt),
        rootFolder: rootFolder,
    }
}
```

## Request Processing Flow

### 1. Input Parsing and Validation
```go
func (s *ServerImpl) CreateAlbum(c *gin.Context) {
    var request v1.CreateAlbumRequest
    if err := c.ShouldBindJSON(&request); err != nil {
        c.JSON(http.StatusBadRequest, v1.Error{
            Message: "Invalid request body",
        })
        return
    }
    // ... continue processing
}
```

### 2. Service Layer Delegation
```go
// Convert API types to entity types
album := entity.NewAlbum(request.Path)
if request.Description != nil {
    album.Description = request.Description  
}

// Delegate to service layer
result, err := s.albumSrv.CreateAlbum(c.Request.Context(), album)
if err != nil {
    // Handle service errors
}
```

### 3. Response Formatting
```go
// Convert entity types back to API types
response := v1.Album{
    Id:          result.ID,
    Href:        fmt.Sprintf("/api/v1/albums/%s", result.ID),
    AlbumHref:   fmt.Sprintf("/api/v1/albums/%s", result.ID),
    // ... other fields
}

c.JSON(http.StatusCreated, response)
```

## Error Handling Patterns

### Service Error Translation
```go
if err != nil {
    if services.IsErrResourceNotFound(err) {
        c.JSON(http.StatusNotFound, v1.Error{Message: "Album not found"})
        return
    }
    
    zap.S().Errorw("failed to create album", "error", err)
    c.JSON(http.StatusInternalServerError, v1.Error{
        Message: "Internal server error",
    })
    return
}
```

### Logging Guidelines
- Log at DEBUG level for successful operations
- Log at WARN level for client errors (4xx)
- Log at ERROR level for server errors (5xx)
- Always include relevant context (IDs, paths, etc.)

## Type Conversion Rules

### API ↔ Entity Mapping
Handlers are responsible for converting between:
- **API Types** (`v1.Album`, `v1.Media`) ↔ **Entity Types** (`entity.Album`, `entity.Media`)
- **Never** pass API types to services
- **Never** return entity types from handlers

### URL Parameter Handling
```go
func (s *ServerImpl) GetAlbum(c *gin.Context, albumId string) {
    // URL parameters are already validated by routing
    album, err := s.albumSrv.GetAlbumByID(c.Request.Context(), albumId)
    // ... handle result
}
```

## Context Propagation
Always pass `c.Request.Context()` to service calls for:
- Request cancellation
- Timeout handling  
- Tracing correlation
- Database transaction context

## Dependencies
Handlers should only depend on:
- **Services**: Business logic layer
- **API Types**: Generated from OpenAPI spec
- **HTTP Framework**: Gin for HTTP handling
- **Logging**: Structured logging with zap